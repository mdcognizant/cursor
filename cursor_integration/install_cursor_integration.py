#!/usr/bin/env python3
"""
Cursor Shell Monitor Integration Installer
Automatically configures Cursor to use shell monitoring for all commands.
"""

import os
import sys
import subprocess
import json
import shutil
from pathlib import Path
import platform

class CursorIntegrationInstaller:
    """Installs shell monitor integration for Cursor."""
    
    def __init__(self):
        self.system = platform.system()
        self.cursor_root = Path(__file__).parent.parent
        self.integration_dir = self.cursor_root / "cursor_integration"
        self.bin_dir = self.integration_dir / "bin"
        self.config_dir = Path.home() / ".cursor_monitor"
        
        # Common commands to wrap
        self.commands_to_wrap = [
            "git", "npm", "node", "python", "pip", "cargo", "rustc",
            "go", "java", "javac", "mvn", "gradle", "docker", "kubectl",
            "terraform", "ansible", "make", "cmake", "gcc", "clang"
        ]
        
    def install(self):
        """Main installation process."""
        print("üöÄ Installing Cursor Shell Monitor Integration...")
        print("="*60)
        
        try:
            self._check_prerequisites()
            self._create_directories()
            self._create_wrapper_scripts()
            self._setup_path_integration()
            self._create_cursor_config()
            self._install_background_service()
            self._create_uninstaller()
            self._print_success_message()
            
        except Exception as e:
            print(f"‚ùå Installation failed: {e}")
            sys.exit(1)
    
    def _check_prerequisites(self):
        """Check if all prerequisites are met."""
        print("üîç Checking prerequisites...")
        
        # Check if shell monitor exists
        monitor_path = self.cursor_root / "shellmonitor" / "monitor.py"
        if not monitor_path.exists():
            raise Exception("Shell Monitor not found. Please ensure it's installed.")
        
        # Check Python version
        if sys.version_info < (3, 6):
            raise Exception("Python 3.6+ required")
        
        print("‚úÖ Prerequisites check passed")
    
    def _create_directories(self):
        """Create necessary directories."""
        print("üìÅ Creating directories...")
        
        self.integration_dir.mkdir(exist_ok=True)
        self.bin_dir.mkdir(exist_ok=True)
        self.config_dir.mkdir(exist_ok=True)
        
        print("‚úÖ Directories created")
    
    def _create_wrapper_scripts(self):
        """Create wrapper scripts for common commands."""
        print("üìù Creating command wrapper scripts...")
        
        wrapper_template = self._get_wrapper_template()
        
        for command in self.commands_to_wrap:
            if self.system == "Windows":
                script_path = self.bin_dir / f"{command}_monitor.bat"
                script_content = self._get_windows_wrapper(command)
            else:
                script_path = self.bin_dir / f"{command}_monitor"
                script_content = wrapper_template.format(command=command)
            
            with open(script_path, 'w', encoding='utf-8') as f:
                f.write(script_content)
            
            # Make executable on Unix-like systems
            if self.system != "Windows":
                os.chmod(script_path, 0o755)
        
        print(f"‚úÖ Created {len(self.commands_to_wrap)} wrapper scripts")
    
    def _get_wrapper_template(self):
        """Get the wrapper script template for Unix-like systems."""
        return '''#!/bin/bash
# Cursor Shell Monitor Wrapper for {command}
# Auto-generated by Cursor Integration Installer

CURSOR_ROOT="{cursor_root}"
WRAPPER_SCRIPT="$CURSOR_ROOT/cursor_integration/cursor_monitor_wrapper.py"

if [ -f "$WRAPPER_SCRIPT" ]; then
    python3 "$WRAPPER_SCRIPT" {command} "$@"
else
    # Fallback to original command if wrapper not found
    {command} "$@"
fi
'''.format(cursor_root=self.cursor_root, command="{command}")
    
    def _get_windows_wrapper(self, command):
        """Get the wrapper script for Windows."""
        return f'''@echo off
REM Cursor Shell Monitor Wrapper for {command}
REM Auto-generated by Cursor Integration Installer

set CURSOR_ROOT={self.cursor_root}
set WRAPPER_SCRIPT=%CURSOR_ROOT%\\cursor_integration\\cursor_monitor_wrapper.py

if exist "%WRAPPER_SCRIPT%" (
    python "%WRAPPER_SCRIPT%" {command} %*
) else (
    REM Fallback to original command if wrapper not found
    {command} %*
)
'''
    
    def _setup_path_integration(self):
        """Set up PATH modifications for Cursor integration."""
        print("üõ§Ô∏è  Setting up PATH integration...")
        
        # Create PATH setup script
        if self.system == "Windows":
            setup_script = self.integration_dir / "setup_cursor_path.bat"
            script_content = f'''@echo off
REM Add Cursor Monitor to PATH
set CURSOR_MONITOR_BIN={self.bin_dir}
set PATH=%CURSOR_MONITOR_BIN%;%PATH%
echo [OK] Cursor Shell Monitor PATH configured
'''
        else:
            setup_script = self.integration_dir / "setup_cursor_path.sh"
            script_content = f'''#!/bin/bash
# Add Cursor Monitor to PATH
export CURSOR_MONITOR_BIN="{self.bin_dir}"
export PATH="$CURSOR_MONITOR_BIN:$PATH"
echo "‚úÖ Cursor Shell Monitor PATH configured"
'''
        
        with open(setup_script, 'w', encoding='utf-8') as f:
            f.write(script_content)
        
        if self.system != "Windows":
            os.chmod(setup_script, 0o755)
        
        print("‚úÖ PATH integration setup created")
    
    def _create_cursor_config(self):
        """Create Cursor-specific configuration."""
        print("‚öôÔ∏è  Creating Cursor configuration...")
        
        cursor_config = {
            "version": "1.0",
            "shell_monitor": {
                "enabled": True,
                "wrapper_path": str(self.integration_dir / "cursor_monitor_wrapper.py"),
                "bin_path": str(self.bin_dir),
                "config_path": str(self.config_dir),
                "default_timeout": 60,
                "auto_diagnose": True,
                "log_commands": True
            },
            "commands": {
                command: {
                    "wrapper": str(self.bin_dir / f"{command}_monitor{'.bat' if self.system == 'Windows' else ''}"),
                    "timeout": 60,
                    "monitor": True
                } for command in self.commands_to_wrap
            }
        }
        
        config_file = self.config_dir / "cursor_monitor_config.json"
        with open(config_file, 'w', encoding='utf-8') as f:
            json.dump(cursor_config, f, indent=2)
        
        print("‚úÖ Cursor configuration created")
    
    def _install_background_service(self):
        """Install background monitoring service."""
        print("üîß Installing background monitoring service...")
        
        service_script = self.integration_dir / "cursor_monitor_service.py"
        service_content = '''#!/usr/bin/env python3
"""
Cursor Shell Monitor Background Service
Monitors Cursor command executions and provides diagnostics.
"""

import time
import sys
import json
import threading
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parent.parent))

from shellmonitor.monitor import ShellMonitor
from shellmonitor.diagnostics import ShellDiagnostics

class CursorMonitorService:
    """Background service for monitoring Cursor commands."""
    
    def __init__(self):
        self.running = False
        self.config_file = Path.home() / ".cursor_monitor_config.json"
        self.log_file = Path.home() / ".cursor_monitor_service.log"
        
    def start(self):
        """Start the monitoring service."""
        self.running = True
        print("üöÄ Cursor Monitor Service started")
        
        try:
            while self.running:
                time.sleep(30)  # Check every 30 seconds
                self._check_system_health()
        except KeyboardInterrupt:
            self.stop()
    
    def stop(self):
        """Stop the monitoring service."""
        self.running = False
        print("üõë Cursor Monitor Service stopped")
    
    def _check_system_health(self):
        """Perform periodic system health checks."""
        try:
            # Run quick diagnostics
            diagnostics = ShellDiagnostics(verbose=False)
            results = diagnostics.run_full_diagnostic()
            
            # Log any warnings or failures
            issues = [r for r in results if r.status in ['warning', 'fail']]
            if issues:
                self._log_issues(issues)
                
        except Exception as e:
            self._log_error(f"Health check failed: {e}")
    
    def _log_issues(self, issues):
        """Log system issues."""
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        with open(self.log_file, 'a') as f:
            f.write(f"[{timestamp}] Issues detected:\\n")
            for issue in issues:
                f.write(f"  - {issue.name}: {issue.message}\\n")
            f.write("\\n")
    
    def _log_error(self, error_msg):
        """Log errors."""
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        with open(self.log_file, 'a') as f:
            f.write(f"[{timestamp}] ERROR: {error_msg}\\n")

if __name__ == "__main__":
    service = CursorMonitorService()
    try:
        service.start()
    except Exception as e:
        print(f"‚ùå Service failed: {e}")
        sys.exit(1)
'''
        
        with open(service_script, 'w', encoding='utf-8') as f:
            f.write(service_content)
        
        if self.system != "Windows":
            os.chmod(service_script, 0o755)
        
        print("‚úÖ Background service installed")
    
    def _create_uninstaller(self):
        """Create uninstaller script."""
        print("üóëÔ∏è  Creating uninstaller...")
        
        if self.system == "Windows":
            uninstaller = self.integration_dir / "uninstall_cursor_integration.bat"
            script_content = f'''@echo off
echo [UNINSTALL] Removing Cursor Shell Monitor Integration...
rmdir /s /q "{self.bin_dir}"
rmdir /s /q "{self.config_dir}"
del /q "{Path.home() / '.cursor_monitor_config.json'}"
del /q "{Path.home() / '.cursor_monitor_commands.log'}"
del /q "{Path.home() / '.cursor_monitor_service.log'}"
echo [OK] Uninstallation complete
pause
'''
        else:
            uninstaller = self.integration_dir / "uninstall_cursor_integration.sh"
            script_content = f'''#!/bin/bash
echo "üóëÔ∏è Uninstalling Cursor Shell Monitor Integration..."
rm -rf "{self.bin_dir}"
rm -rf "{self.config_dir}"
rm -f "{Path.home() / '.cursor_monitor_config.json'}"
rm -f "{Path.home() / '.cursor_monitor_commands.log'}"
rm -f "{Path.home() / '.cursor_monitor_service.log'}"
echo "‚úÖ Uninstallation complete"
'''
        
        with open(uninstaller, 'w', encoding='utf-8') as f:
            f.write(script_content)
        
        if self.system != "Windows":
            os.chmod(uninstaller, 0o755)
        
        print("‚úÖ Uninstaller created")
    
    def _print_success_message(self):
        """Print installation success message."""
        print("\n" + "="*60)
        print("üéâ CURSOR SHELL MONITOR INTEGRATION INSTALLED!")
        print("="*60)
        
        print("\\nüìã Next Steps:")
        
        if self.system == "Windows":
            print("1. Run this command to activate in your current session:")
            print(f"   {self.integration_dir / 'setup_cursor_path.bat'}")
            print("\\n2. Add to your PowerShell profile for permanent activation:")
            print(f"   Add-Content $PROFILE '{self.integration_dir / 'setup_cursor_path.bat'}'")
        else:
            print("1. Run this command to activate in your current session:")
            print(f"   source {self.integration_dir / 'setup_cursor_path.sh'}")
            print("\\n2. Add to your shell profile for permanent activation:")
            print(f"   echo 'source {self.integration_dir / 'setup_cursor_path.sh'}' >> ~/.bashrc")
        
        print("\\n3. Restart Cursor to use the monitored commands")
        
        print("\\nüîß Available Commands:")
        for cmd in self.commands_to_wrap[:5]:  # Show first 5
            suffix = "_monitor.bat" if self.system == "Windows" else "_monitor"
            print(f"   {cmd}{suffix} - Monitored version of {cmd}")
        print(f"   ... and {len(self.commands_to_wrap) - 5} more commands")
        
        print("\\nüìä Monitoring Features:")
        print("   ‚úÖ Automatic timeout handling")
        print("   ‚úÖ Command performance tracking") 
        print("   ‚úÖ System diagnostics")
        print("   ‚úÖ Interactive recovery options")
        print("   ‚úÖ Background health monitoring")
        
        print("\\nüìÅ Configuration Files:")
        print(f"   Config: {self.config_dir / 'cursor_monitor_config.json'}")
        print(f"   Logs: {Path.home() / '.cursor_monitor_commands.log'}")
        
        print("\\nüóëÔ∏è To Uninstall:")
        uninstaller_name = "uninstall_cursor_integration.bat" if self.system == "Windows" else "uninstall_cursor_integration.sh"
        print(f"   {self.integration_dir / uninstaller_name}")

def main():
    """Main installer execution."""
    print("üîß Cursor Shell Monitor Integration Installer")
    print("="*60)
    
    installer = CursorIntegrationInstaller()
    installer.install()

if __name__ == "__main__":
    main() 